---
slug: offline-first-structure
title: Offline-first Structure
authors:
  name: Christopher Kiessling
  title: Ninja Software Engineer
  url: https://github.com/crsk
  image_url: https://github.com/crsk.png
tags: []
---

## Objective
The idea in this article is to document the process of dealing with a local approach where the user uses its own device to run the app (create, move, connect nodes and give them instructions) until they feel comfortable to create an account. Yep! No previous login as Tiktok does. You install it, you play it until you're addicted, then create an account to store, like, comment, and share these amazing kittens.

## Why
Since it is important to have a solid structure, I decided to proceed with a Redux offline-first approach. It would take a little longer now but it would be architecture solid, resistant to bugs, easy to debug, and there would also be an improvement in user experience.

Talking about experience, I once worked on a project where we implemented a state management and offline persistence module in a fast-paced environment, we didn't take enough time to think about the architecture implementation, and since this is so interconnected with pretty much all the system, it ended up hindering the app development progress, just like what is shown in the following illustrations

### The cost of repair on technical debt
![Image](./cost-repair.png)
<div className="caption">
  Development costs: https://martinfowler.com/bliki/Yagni.html
</div>

### Scenario comparison
![Image](./curve.png)
<div className="caption">
  Software development: normal vs worst-case efficiency
</div>

## Technical considerations
- To avoid the hassle of updating temporary IDs, unique IDs can be generated by the client for each Node.
- When syncing changes with the server, bulk operations can be performed in order of creation, update, and deletion.
- The prev item can be further optimized by cancelling unnecessary operations (e.g. don't update if later deleted).
- Nodes should be created by their parents first to avoid SQL error by creating a child with a non-existing parent_id.
- Using tools and patterns like Redux can be helpful in designing a well-thought-out mechanism.
- There are additional concerns to consider, such as conflict resolution and queue implementation.

## Implementation
### Libraries
I'm going to use a set of libraries that will help with implementing a solid base to start building from, these are:
- Redux: Predictable state container for JavaScript apps.
- Redux-toolkit: Toolset for efficient Redux development.
- Redux-observable: RxJS-based middleware for Redux. Compose and cancel async actions.
- Redux-persist: Persist and rehydrate a redux store.
- Async-storage: Storage engine.

### Flux architecture
Flux is a well-established pattern used to manage data flow in React applications. Redux, a popular implementation of Flux, efficiently handles asynchronous operations as illustrated here:
![Async Redux flow animation](https://redux.js.org/assets/images/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif)
<div className="caption">
  https://redux.js.org/tutorials/fundamentals/part-6-async-logic
</div>

However, to further enhance this mechanism, let's extend it to support RxJS and persistence over a queue mechanism. By doing so, the resulting implementation will have the capability to handle complex data flows and ensure data persistence even in case of network disruptions. The following image demonstrates the end result:

![Image](./redux-queue.png)
<div className="caption">
  Redux queue flow
</div>

![Image](./sync-flow.png)
<div className="caption">
  Redux synchronization flow
</div>

### Code
![Image](./code-flow.png)
<div className="caption">
  Simplified overview
</div>

I've created a `handleRemoteEpic` function to easily include operations other than "Add", it also avoids calling the API if the user is not logged in:
```tsx
const handleRemoteEpic = (actionType: string, apiMethod: (payload: any) => Promise<any>): Epic<any, any, RootState> => (action$, state$) => action$.pipe(
  ofType(actionType),
  debounceTime(DEBOUNCE_TIME),
  switchMap(({ payload }: { payload: any }) => (
    state$.value.login?.user
      ? from(apiMethod(payload)).pipe(
        map(() => ({ type: ActionEnumMap[actionType], payload })),
        catchError(() => storeLocalHandler(actionType, payload)),
      )
      : storeLocalHandler(actionType, payload) // no user logged in, nothing to save in the backend
  )),
)

const addNodeEpic = handleRemoteEpic(addNodeTrigger.type, nodeApi.create)
const deleteNodeEpic = handleRemoteEpic(deleteNodeTrigger.type, nodeApi.delete)
const updateNodeEpicRemote = handleRemoteEpic(updateNodeTrigger.type, nodeApi.update)
```

```tsx
const ActionEnumMap: Record<string, NodeActionTypes> = {
  [addNodeTrigger.type]: NodeActionTypes.ADD,
  [updateNodeTrigger.type]: NodeActionTypes.UPDATE,
  [deleteNodeTrigger.type]: NodeActionTypes.DELETE,
}

const QueueActionEnumMap: Record<string, QueueActionTypes> = {
  [addNodeTrigger.type]: QueueActionTypes.ADD_NODE,
  [updateNodeTrigger.type]: QueueActionTypes.UPDATE_NODE,
  [deleteNodeTrigger.type]: QueueActionTypes.DELETE_NODE,
}
const storeLocalHandler = (actionType: string, payload: any) => concat(
  of({ type: QueueActionEnumMap[actionType], payload }),
  of({ type: ActionEnumMap[actionType], payload }),
)
```

### Synchronization logic
After some offline activity, our queue should look something like this:
```js
QUEUE: {
  NODE: {
    ADD: {
      'some-client-side-generated-id': {
        id: 'some-client-side-generated-id',
        parentId: 'some-other-client-side-id',
        x: 300,
        y: 600,
      },
      'some-client-side-generated-id': {
        id: 'some-client-side-generated-id',
        parentId: 'some-other-client-side-id',
        x: 400,
        y: 800,
      },
    },
    UPDATE: {
      'some-client-side-generated-id': {
        id: 'some-client-side-generated-id',
        propsToUpdate: {
          x: 1200,
          y: 720,
        },
      },
    },
    DELETE: {
      'some-client-side-generated-id': {
        id: 'some-client-side-generated-id',
      },
      'some-client-side-generated-id': {
        id: 'some-client-side-generated-id',
      },
    }
  }
}
```

Let's iterate through and call the bulk-creation API
```tsx
const syncEpic: Epic<any, any, RootState> = (action$, state$) => action$.pipe(
  ofType(syncNodesTrigger.type),
  mergeMap(() => {
    const { ADD, UPDATE, DELETE }: QueueOperation<CreateNodeBody, UpdateNodeBody, DeleteNodeParams> = state$.value.queue.NODE
    const unsyncedNodes: { actionType: QueueActionTypes, payload: (CreateNodeBody | UpdateNodeBody | DeleteNodeParams) }[] = [
      ...Object.values(ADD).map((payload) => ({ actionType: QueueActionTypes.ADD_NODE, payload })),
      ...Object.values(UPDATE).map((payload) => ({ actionType: QueueActionTypes.UPDATE_NODE, payload })),
      ...Object.values(DELETE).map((payload) => ({ actionType: QueueActionTypes.DELETE_NODE, payload })),
    ]

    return unsyncedNodes.length === 0
      ? EMPTY
      : from(unsyncedNodes).pipe(groupBy((node) => node.actionType), mergeMap((group) => group.pipe(toArray())), concatMap((actionGroup) => {
        const { actionType } = actionGroup[0]

        switch (actionType) {
          case QueueActionTypes.ADD_NODE:
            return from(nodeApi.bulkCreate(actionGroup.map((action) => action.payload as CreateNodeBody))).pipe(
              mergeMap(() => actionGroup.map((action) => ({
                type: QueueActionTypes.DELETE_FROM_QUEUE,
                payload: { operation: 'ADD', id: (action.payload as CreateNodeBody).id },
              }))),
              catchError(() => EMPTY),
            )
          case QueueActionTypes.UPDATE_NODE:
            return from(nodeApi.bulkUpdate(actionGroup.map((action) => action.payload as UpdateNodeBody))).pipe(
              mergeMap(() => actionGroup.map((action) => ({
                type: QueueActionTypes.DELETE_FROM_QUEUE,
                payload: { operation: 'UPDATE', id: (action.payload as UpdateNodeBody).id },
              }))),
              catchError(() => EMPTY),
            )
          case QueueActionTypes.DELETE_NODE:
            return from(nodeApi.bulkDelete(actionGroup.map((action) => action.payload as UpdateNodeBody))).pipe(
              mergeMap(() => actionGroup.map((action) => ({
                type: QueueActionTypes.DELETE_FROM_QUEUE,
                payload: { operation: 'DELETE', id: (action.payload as DeleteNodeParams).id },
              }))),
              catchError(() => EMPTY),
            )
          default:
            return EMPTY
        }
      }))
  }),
)
```

### Server side
Finally, let's check if the current node in the bulk operation has an already non-inserted parent. If so, commit the transaction and start a new one for the upcoming inserts.
```tsx
export const runTransaction = async <T extends QueryResult>(queries: Array<{ query: string, id: string }>): Promise<T[]> => withConnection(async (client: PoolClient) => {
  try {
    await client.query('BEGIN')
    const results = await Promise.all(queries.map(({ query }) => client.query<T>(query)))
    await client.query('COMMIT')

    return results as T[]
  } catch (err) {
    console.error('Transaction error:', err)
    await client.query('ROLLBACK')
    throw err
  }
})
```
```tsx
export const createNodes = async (newNodes: SnakeCase<CreateNodeBody>[]): Promise<number | undefined> => {
  let transactionQueries: { query: string, id: string }[] = []
  const queryResult = []

  const commitTransaction = async () => {
    if (transactionQueries.length > 0) {
      const results = await runTransaction(transactionQueries)
      queryResult.push(...results)
      transactionQueries = []
    }
  }

  for (const node of newNodes) {
    const isParentInTransaction = transactionQueries.some((q) => q.id === node.parent_id)
    if (isParentInTransaction) await commitTransaction()

    const columns = Object.keys(node)
    const values = Object.values(node)
    const query = format('INSERT INTO %I (%I) VALUES (%L)', 'node', columns, values)

    transactionQueries.push({ query, id: node.id })
  }
  await commitTransaction()

  return queryResult.length
}
```

## Final result
I know it seems like some overhead, but hey, solid foundation, your future self will appreciate it 😉

You can take a tour of the full implementation here: https://github.com/Crsk/frow

Now that everything is implemented, you can try it by yourself. Go to https://crsk.github.io/frow/, turn off your internet connection, and start playing with the nodes.
